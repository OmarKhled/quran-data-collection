// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO USERS (
  "name", email, country, province, age, gender, proficiency_level, studied_quran_before, job_title, lisper
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id
`

type CreateUserParams struct {
	Name               string      `json:"name"`
	Email              string      `json:"email"`
	Country            string      `json:"country"`
	Province           string      `json:"province"`
	Age                int32       `json:"age"`
	Gender             Gender      `json:"gender"`
	ProficiencyLevel   string      `json:"proficiency_level"`
	StudiedQuranBefore bool        `json:"studied_quran_before"`
	JobTitle           pgtype.Text `json:"job_title"`
	Lisper             pgtype.Text `json:"lisper"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int32, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Name,
		arg.Email,
		arg.Country,
		arg.Province,
		arg.Age,
		arg.Gender,
		arg.ProficiencyLevel,
		arg.StudiedQuranBefore,
		arg.JobTitle,
		arg.Lisper,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createUserTask = `-- name: CreateUserTask :exec
INSERT INTO USER_TASKS (
  user_id, task_id, audio_url, audio_duration
) VALUES (
  $1, $2, $3, $4
)
`

type CreateUserTaskParams struct {
	UserID        int32   `json:"user_id"`
	TaskID        int32   `json:"task_id"`
	AudioUrl      string  `json:"audio_url"`
	AudioDuration float64 `json:"audio_duration"`
}

func (q *Queries) CreateUserTask(ctx context.Context, arg CreateUserTaskParams) error {
	_, err := q.db.Exec(ctx, createUserTask,
		arg.UserID,
		arg.TaskID,
		arg.AudioUrl,
		arg.AudioDuration,
	)
	return err
}

const getAyahs = `-- name: GetAyahs :many
SELECT id, ayah, surah, page, text, glyphs FROM AYAHS
`

func (q *Queries) GetAyahs(ctx context.Context) ([]Ayah, error) {
	rows, err := q.db.Query(ctx, getAyahs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ayah
	for rows.Next() {
		var i Ayah
		if err := rows.Scan(
			&i.ID,
			&i.Ayah,
			&i.Surah,
			&i.Page,
			&i.Text,
			&i.Glyphs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTask = `-- name: GetTask :one
SELECT t.id, ay.surah, ay.ayah, ay.text, ay.glyphs, ay.page
FROM TASKS t
LEFT JOIN USER_TASKS ut ON t.id = ut.task_id
JOIN AYAHS ay ON t.ayah = ay.id
WHERE t.is_deleted = FALSE
GROUP BY t.id, ay.id
ORDER BY COUNT(ut.id) ASC, RANDOM()
LIMIT 1
`

type GetTaskRow struct {
	ID     int32  `json:"id"`
	Surah  int32  `json:"surah"`
	Ayah   int32  `json:"ayah"`
	Text   string `json:"text"`
	Glyphs string `json:"glyphs"`
	Page   int32  `json:"page"`
}

func (q *Queries) GetTask(ctx context.Context) (GetTaskRow, error) {
	row := q.db.QueryRow(ctx, getTask)
	var i GetTaskRow
	err := row.Scan(
		&i.ID,
		&i.Surah,
		&i.Ayah,
		&i.Text,
		&i.Glyphs,
		&i.Page,
	)
	return i, err
}

const getTotalDurations = `-- name: GetTotalDurations :one
SELECT COALESCE(SUM(audio_duration), 0) AS total_duration FROM USER_TASKS
`

func (q *Queries) GetTotalDurations(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, getTotalDurations)
	var total_duration interface{}
	err := row.Scan(&total_duration)
	return total_duration, err
}

const getUser = `-- name: GetUser :one
SELECT id FROM USERS
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, email string) (int32, error) {
	row := q.db.QueryRow(ctx, getUser, email)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getUserTotalDuration = `-- name: GetUserTotalDuration :one
SELECT COALESCE(SUM(audio_duration), 0) AS total_duration FROM USER_TASKS 
WHERE user_id = $1
`

func (q *Queries) GetUserTotalDuration(ctx context.Context, userID int32) (interface{}, error) {
	row := q.db.QueryRow(ctx, getUserTotalDuration, userID)
	var total_duration interface{}
	err := row.Scan(&total_duration)
	return total_duration, err
}
